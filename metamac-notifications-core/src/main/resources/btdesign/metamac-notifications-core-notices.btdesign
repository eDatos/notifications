import "classpath:/btdesign/metamac-notifications-core-common.btdesign"

Application Notices { 
	basePackage=unused

	Module enume_notice {
		basePackage=org.siemac.metamac.notifications.core.notice.enume
		
		enum NotificationType {
    		NOTIFICATION,
    		ADVERTISEMENT
    	}
    	
	}
	
	Module domain_notice {
		basePackage=org.siemac.metamac.notifications.core.notice

		// ----------------------------------------------------------------
		// 							SERVICES
		// ----------------------------------------------------------------
		
		Service NotificationService {
			> @NotificationRepository
			> @ReceiverRepository
			
			// Notifications
			@Notification findNotificationById(Long id) throws MetamacException;
			@Notification retrieveNotificationByUrn(String urn) throws MetamacException;
			@Notification createNotification(@Notification notification) throws MetamacException;
    		@Notification updateNotification(@Notification notification) throws MetamacException;
    		deleteNotification(Long id) throws MetamacException;
    		List<@Notification> findAllNotification throws MetamacException;
    		List<@Notification> findNotificationByCondition(List<ConditionalCriteria> condition) throws MetamacException;
			
		}  

		// ----------------------------------------------------------------
		// 							ENTITIES
		// ---------------------------------------------------------------- 

		Entity Notification {
			databaseTable="TB_NOTIFICATIONS"
			hint="idSequence=NOTIFICATIONS"
			
			"Added explicitly to avoid that Sculptor generate UUID"
			Long id key;
			"Universal resource name, this is for use in registries: all registered objects have a urn"
			String urn nullable;
			
			"Sending application ID"
			String sendingApplication required;
			"Sending user"
			String sendingUser nullable;
			"Mail"
       		String mail nullable;
       		"Expiration date. Only valid when notificationType is ADVERTISEMENT"
			DateTimeTZ expirationDate nullable; 
       		"Type of notification"
       		- @NotificationType notificationType required;
       		"Mark"
			boolean mark;
			
       		"Required roles access for notification"
       		- Bag<@Role> roles cascade="all-delete-orphan" fetch="lazy" inverse <-> notification;
       		"Receivers"
			- Bag<@Receiver> receivers cascade="all-delete-orphan" fetch="lazy" inverse <-> notification;
			"Applications"
			- Bag<@App> apps cascade="all-delete-orphan" fetch="lazy" inverse <-> notification;
       		"Required statistical operations access for notification"
			- Bag<@ExternalItem> statisticalOperations databaseColumn="STAT_OPE_FK" databaseJoinColumn="NOTIFICATION_FK" databaseJoinTable="TB_NOTIF_OPES" cascade="all-delete-orphan";
			"Message"       		
			Clob message required;
			
			Repository NotificationRepository {
				save;
				delete;
				findAll;
				findById;
				findByCondition;
				findByCondition(PagingParameter pagingParameter);
				findByQuery(String query, Map<String, Object> parameters, int maxResult);
				@Notification retrieveByUrn(String urn) throws MetamacException;
			}
		}
		
		Entity Receiver {
			databaseTable="TB_RECEIVERS"
			hint="idSequence=RECEIVERS"
			not auditable
			
			"Added explicitly to avoid that Sculptor generate UUID"
			Long id key;
			
			"Semantic identifier"
       		String username not nullable;
       		"Acknowledgeâ€Ž"
       		boolean acknowledge;

			"Notification"
			- @Notification notification not nullable cascade="none" databaseColumn="RECEIVER_FK" <-> receivers;
			
			Repository ReceiverRepository {
				save;
				delete;
				findAll;
				findById;
				findByCondition;
				findByCondition(PagingParameter pagingParameter);
				findByQuery(String query, Map<String, Object> parameters, int maxResult);
			}
		}
		
		Entity Role {
			databaseTable="TB_ROLES"
			hint="idSequence=ROLES"
			not auditable
			
			"Added explicitly to avoid that Sculptor generate UUID"
			Long id key;
			
			"Semantic identifier"
       		String name not nullable;

			"Notification"
			- @Notification notification not nullable cascade="none" databaseColumn="ROLE_FK" <-> roles;
			
			Repository RoleRepository {
				save;
				delete;
				findAll;
				findById;
				findByCondition;
				findByCondition(PagingParameter pagingParameter);
				findByQuery(String query, Map<String, Object> parameters, int maxResult);
			}
		}
		
		Entity App {
			databaseTable="TB_APPS"
			hint="idSequence=APPS"
			not auditable
			
			"Added explicitly to avoid that Sculptor generate UUID"
			Long id key;
			
			"Semantic identifier"
       		String name not nullable;

			"Notification"
			- @Notification notification not nullable cascade="none" databaseColumn="APP_FK" <-> apps;
			
			Repository AppRepository {
				save;
				delete;
				findAll;
				findById;
				findByCondition;
				findByCondition(PagingParameter pagingParameter);
				findByQuery(String query, Map<String, Object> parameters, int maxResult);
			}
		}
	}
}