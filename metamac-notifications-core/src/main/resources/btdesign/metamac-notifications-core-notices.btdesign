import "classpath:/btdesign/metamac-notifications-core-common.btdesign"

Application Notices { 
	basePackage=unused

	Module enume_notice {
		basePackage=org.siemac.metamac.notifications.core.notice.enume
		
		enum NotificationType {
    		NOTIFICATION,
    		ADVERTISEMENT
    	}
    	
	}
	
	Module domain_notice {
		basePackage=org.siemac.metamac.notifications.core.notice

		// ----------------------------------------------------------------
		// 							SERVICES
		// ----------------------------------------------------------------
		
		Service NotificationService {
			> @NotificationRepository
			> @ReceiverRepository
			
			// Notifications
			@Notification findNotificationById(Long id) throws MetamacException;
			@Notification retrieveNotificationByUrn(String urn) throws MetamacException;
			@Notification createNotification(@Notification notification) throws MetamacException;
    		@Notification updateNotification(@Notification notification) throws MetamacException;
    		deleteNotification(Long id) throws MetamacException;
    		List<@Notification> findAllNotification throws MetamacException;
    		List<@Notification> findNotificationByCondition(List<ConditionalCriteria> condition) throws MetamacException;
			
		}  

		// ----------------------------------------------------------------
		// 							ENTITIES
		// ---------------------------------------------------------------- 

		Entity Notification {
			databaseTable="TB_NOTIFICATIONS"
			hint="idSequence=NOTIFICATIONS"
			
			"Added explicitly to avoid that Sculptor generate UUID"
			Long id key;
			"Universal resource name, this is for use in registries: all registered objects have a urn"
			String urn nullable;
			
			"Sending application ID"
			String sendingApplication required;
			"Sending user"
			String sendingUser nullable;
       		"Expiration date. Only valid when notificationType is ADVERTISEMENT"
			DateTimeTZ expirationDate nullable; 
       		"Type of notification"
       		- @NotificationType notificationType required;
       		"Mark"
			boolean mark;
			
			"Subject"
			String subject required length="4000";
			"Messages"
			- Bag<@Message> messages cascade="all-delete-orphan" fetch="lazy" inverse <-> notification;
       		"Required roles access for notification"
       		- Bag<@Role> roles cascade="all-delete-orphan" fetch="lazy" inverse <-> notification;
       		"Receivers"
			- Bag<@Receiver> receivers cascade="all-delete-orphan" fetch="lazy" inverse <-> notification;
			"Applications"
			- Bag<@App> apps cascade="all-delete-orphan" fetch="lazy" inverse <-> notification;
       		"Required statistical operations access for notification"
			- Bag<@StatisticalOperation> statisticalOperations cascade="all-delete-orphan" fetch="lazy" inverse <-> notification;
			
			Repository NotificationRepository {
				save;
				delete;
				findAll;
				findById;
				findByCondition;
				findByCondition(PagingParameter pagingParameter);
				findByQuery(String query, Map<String, Object> parameters, int maxResult);
				@Notification retrieveByUrn(String urn) throws MetamacException;
			}
		}

		Entity Message {
			databaseTable="TB_MESSAGES"
			hint="idSequence=MESSAGES"
			not auditable
			
			"Added explicitly to avoid that Sculptor generate UUID"
			Long id key;
			
			"Text"       		
			Clob text required;
			
			"Resources"
			- Bag<@ExternalItem> resources databaseColumn="RESOURCE_FK" databaseJoinColumn="MESSAGE_FK" databaseJoinTable="TB_MESSAGE_RESOURCES" cascade="all-delete-orphan";

			"Notification"
			- @Notification notification not nullable cascade="none" databaseColumn="MESSAGE_FK" <-> messages;
			
			Repository MessageRepository {
				save;
				delete;
				findAll;
				findById;
				findByCondition;
				findByCondition(PagingParameter pagingParameter);
				findByQuery(String query, Map<String, Object> parameters, int maxResult);
			}
		}

		
		Entity Receiver {
			databaseTable="TB_RECEIVERS"
			hint="idSequence=RECEIVERS"
			not auditable
			
			"Added explicitly to avoid that Sculptor generate UUID"
			Long id key;
			
			"Semantic identifier"
       		String username not nullable;
       		"Acknowledgeâ€Ž"
       		boolean acknowledge;

			"Notification"
			- @Notification notification not nullable cascade="none" databaseColumn="RECEIVER_FK" <-> receivers;
			
			Repository ReceiverRepository {
				save;
				delete;
				findAll;
				findById;
				findByCondition;
				findByCondition(PagingParameter pagingParameter);
				findByQuery(String query, Map<String, Object> parameters, int maxResult);
			}
		}
		
		Entity Role {
			databaseTable="TB_ROLES"
			hint="idSequence=ROLES"
			not auditable
			
			"Added explicitly to avoid that Sculptor generate UUID"
			Long id key;
			
			"Semantic identifier"
       		String name not nullable;

			"Notification"
			- @Notification notification not nullable cascade="none" databaseColumn="ROLE_FK" <-> roles;
			
			Repository RoleRepository {
				save;
				delete;
				findAll;
				findById;
				findByCondition;
				findByCondition(PagingParameter pagingParameter);
				findByQuery(String query, Map<String, Object> parameters, int maxResult);
			}
		}
		
		Entity App {
			databaseTable="TB_APPS"
			hint="idSequence=APPS"
			not auditable
			
			"Added explicitly to avoid that Sculptor generate UUID"
			Long id key;
			
			"Semantic identifier"
       		String name not nullable;

			"Notification"
			- @Notification notification not nullable cascade="none" databaseColumn="APP_FK" <-> apps;
			
			Repository AppRepository {
				save;
				delete;
				findAll;
				findById;
				findByCondition;
				findByCondition(PagingParameter pagingParameter);
				findByQuery(String query, Map<String, Object> parameters, int maxResult);
			}
		}
		
		Entity StatisticalOperation {
			databaseTable="TB_STATISTICAL_OPERATIONS"
			hint="idSequence=STATISTICAL_OPERATIONS"
			not auditable
			
			"Added explicitly to avoid that Sculptor generate UUID"
			Long id key;
			
			"Semantic identifier"
       		String name not nullable;

			"Notification"
			- @Notification notification not nullable cascade="none" databaseColumn="STATISTICAL_OPERATION_FK" <-> statisticalOperations;
			
			Repository StatisticalOperationRepository {
				save;
				delete;
				findAll;
				findById;
				findByCondition;
				findByCondition(PagingParameter pagingParameter);
				findByQuery(String query, Map<String, Object> parameters, int maxResult);
			}
		}
	}
}